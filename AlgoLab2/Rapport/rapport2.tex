\documentclass[10pt,a4paper]{article}
\usepackage{geometry}
\usepackage[french]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern} \normalfont
\DeclareFontShape{T1}{lmr}{bx}{sc}{<-> ssub * cmr/bx/sc}{}
\usepackage{textcomp}
\usepackage{datetime}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{subcaption}
\usepackage{tocloft}
\usepackage{fixltx2e}
\usepackage{color}
\usepackage[colorlinks=true,
			linkcolor=blue,
			bookmarksnumbered=true,
			pdftitle={Rapport INF4705},
			pdfauthor={Gwenegan Hudin},
			pdfborder={0 0 0},
			pdfsubject={Stage 3INFO}]{hyperref}

% Custom commands
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
\newcommand{\Section}[1]{\section*{#1} \addcontentsline{toc}{section}{#1} \setcounter{subsection}{0}}
%\renewcommand*{\theHsection}{chY.\the\value{section}}
\renewcommand{\thesection}{\Roman{section}.}
\renewcommand{\thesubsection}{\arabic{subsection}.}
\renewcommand{\thesubsubsection}{\alph{subsubsection}.}
\renewcommand{\cftsecnumwidth}{2em}
\renewcommand{\cftsubsecnumwidth}{2em}
\renewcommand{\cftsubsubsecnumwidth}{2em}
\addto\captionsfrench{
	\renewcommand{\cfttoctitlefont}{\Large}
	\renewcommand{\contentsname}{\centering \textsc{Table des Matières}\\[0.5cm]}
}

\renewcommand{\baselinestretch}{1.15}

\begin{document}

\begin{titlepage}
	\begin{center}
		\begin{figure}
        \begin{subfigure}[c]{0.2\textwidth}
        		\centering
                \includegraphics[width=0.6\textwidth]{images/logo-polymtl}
        \end{subfigure}
		\end{figure}
		
		
		\vspace{30pt}
		\textsc{\huge Génie Informatique}\\
		\textsc{\LARGE Rapport de Travaux Pratiques}\\		
		\vfill
		
		% Title
		\HRule \\[0.7cm]
		{\Huge \bfseries INF4705 : Lab 2}\\[0.4cm]
		{\Large Algorithmes voraces et dynamiques : Application au tri topologique d'un graphe}\\[0.2cm]
		\HRule\\[1cm]
		
		\vfill
		
		% Author
		\begin{minipage}{0.49\textwidth}
			\begin{flushleft} \LARGE
				\textbf{Auteur}\\
				Gwenegan \textsc{Hudin}\\ 1756642\\[0.5cm]
			\end{flushleft}
		\end{minipage}
		\begin{minipage}{0.49\textwidth}
			\begin{flushright} \LARGE
				\textbf{Rendu}\\
				14 Novembre 2014\\ À Polytechnique Montréal\\[0.5cm]
			\end{flushright}
		\end{minipage}
	\end{center}
\end{titlepage}

\newpage

\hfill

\newpage

\tableofcontents

\newpage

\section{Introduction}

Lors de cette expérience, nous allons couvrir le problème de tri topologique de graphes orientés acycliques selon trois approches : vorace, retour arrière et dynamique. Plus que les tris en eux-mêmes, nous nous intéresserons au nombre de permutations de tri détectées par chaque algorithme, et leurs vitesses respectives. Ces permutations seront nommées \og extensions linéaires \fg d'un graphe.

Au début de l'expérience, nous n'avons pas de suppositions de précédence d'une méthode sur une autre, et nous n'avons donc pas d'hypothèse précise à vérifier, contrairement au rapport précédent. Nous pouvons simplement supposer que l'algorithme vorace, dont l'utilisation afin de déterminer le nombre d'extensions linéaires repose sur une approximation par formule mathématique, sera moins précis que les deux autres méthodes.

L'on peut aussi supposer que l'algorithme de programmation dynamique, reposant sur une structure de données à $N$ dimensions, sera bien plus coûteux et difficile à implémenter, mais plus rapide que l'algorithme exhaustif de retour arrière.

Ce rapport a pour but de présenter les différents résultats obtenus avec chaque implémentation, appliquer des analyses asympotiques et hybrides, et de discuter des méthodes utilisées.

\section{Revue de la théorie}

Dans ce rapport, tous les graphes évoqués seront considérés orientés et acycliques, et définis formellement comme suit : $ G = (S,A) $, avec $S$ ensemble de sommets $\{1, \ldots, n\}$ et $A$ ensemble d'arcs tels que $ A \subset S \times S $.

On définit un tri topologique de $G$ comme étant une permutation $ \sigma $ de $ S $ telle que $ (i,j) \in A \longrightarrow \sigma(i) < \sigma(j) $.

Les trois méthodes reposent sur une mécanique similaire : détecter les sommets dont le degré entrant est nul, les traiter, les ignorer, itérer.

\subsection{Fonctionnement de l'algorithme vorace}

Contrairement aux deux autres méthodes que nous verrons, l'algorithme vorace ne vise pas directement l'obtention des extensions linéaires du graphe. 

Pour déterminer le nombre de permutations, l'algorithme calcule une décomposition du graphe en chaînes, de longueur décroissante. Ces chaînes sont calculées itérativement, en enlevant à chaque fois les sommets du graphe gérés.

Ensuite, cette décomposition permet d'approximer le nombre d'extensions linéaires selon $ 2^{ \frac{1}{2} n H(G)} $, où $ H(G) = \sum_{i=1}^{k} (- \frac{|c_{i}|}{|S|} log \frac{|c_{i}|}{|S|} ) $.

Lors de la recherche d'une chaîne la plus longue, le pire cas surviendrait si tous les sommets sauf un étaient connectés seulement à ce dernier. La file contiendrait alors $ |S| - 1 $ éléments. Cependant, l'ajout / retrait dans une file est trivial et se déroule en $ O(1) $. La recherche d'élément est plus problématique, une file n'étant pas triée, et cette vitesse dépendra donc de l'implémentation. Afin de simplifier ajout et retrait d'élément, et utilisation comme file (avec ajout en avant ou en fond de file), une liste chaînée est utilisée, dans laquelle la recherche s'effectue en $ O(n) $ selon la méthode \textit{find} de la STL.
Notons que s'il n'y a aucun arc dans le graphe, nous aurons un tour de boucle supplémentaire, mais la recherche dans la structure n'est plus effectuée, et l'opération est plus rapide. Pour trouver toutes les chaînes, on répète cette opération jusqu'à ce qu'il n'y ait plus de chaîne valide, soit au maximum $ |S| $ fois.
Cette méthode a donc une complexité polynomiale, en $ O(|S|^{2}) $.

\subsection{Fonctionnement de l'algorithme retour arrière}

L'algorithme de retour arrière, ou \textit{backtracking}, s'apparente à la contruction et au parcours d'un arbre de solutions. À la racine de l'arbre se trouve le noeud vide, qui a un noeud fils par sommet de degré entrant 0 dans le graphe G.

À chaque embranchement, l'algorithme construit la chaîne en ajoutant un des sommets disponibles. Cette construction, dont les feuilles aboutissent toujours à une solution valide du problème, permet de revenir à un embranchement précédent pour explorer les autres solutions possibles.

Ainsi, le nombre de feuilles de l'arbre construit de la sorte correspond exactement au nombre de permutations possibles. Cette méthode est donc plus précise que l'approximation mathématique, mais elle est bien plus coûteuse, de par les nombreux embranchements nécessaires à la récursion sur un graphe important, comme nous le verrons, bien qu'il ne soit pas nécessaire de garder les permutations en mémoire.

%Sans la récursivité, la méthode de base pour trouver une seule extension appartient à $ O (|S| \times |A|) $.

Cette méthode teste toutes les permutations possibles de manière exhaustive, et est donc en temps super-polynomial, appartenant à $ O (|S|!) $.

\subsection{Fonctionnement de l'algorithme dynamique}

En général, on utilise le patron de conception algorithmique dynamique lorsqu'il est possible de subdiviser un problème en sous-problèmes que l'on peut recombiner, et dont la résolution demande des calculs redondants.

Contrairement aux algorithmes diviser-pour-régner, qui adoptent une approche \textit{top-down}, la programmation dynamique repose sur une méthodologie \textit{bottom-up}. Connaissant un cas de base qui permet de remplir les \og bords \fg du tableau de calculs, chaque case du tableau est remplie en fonction des précédentes, évitant ainsi tout calcul inutile.

L'intérêt est de remplir le tableau jusqu'à arriver à la toute dernière case, qui sera notre solution, sans jamais répéter d'opération. On part du cas de base, et on remonte vers la solution.

Ici, nous savons que le nombre d'extensions linéaires d'un graphe est égal à la somme des extensions linéaires de ses sous-graphes dont on a retiré les arcs entrants. On se base donc sur la décomposition vorace en chaînes d'un graphe évoquée précédemment.

Le nombre de chaînes étant variable et non borné, le tableau de données devra être pensé pour gérer $ N $ dimensions.

\section{Protocole expérimental}

\subsection{Environnement de développement}

Les tests ont été effectués sur un système ArchLinux 64bits, kernel 3.16.3-1-ARCH en environnement Gnome3, sur une machine disposant de 8Go de mémoire vive et d'un processeur i7-2630QM cadencé à 2.00GHz. L'ordinateur portable a reposé sur une station ventilée pendant toute la durée des calculs.

Le programme a été écrit en C++ 11 et compilé avec GCC 4.9.1.

\subsection{Déroulement de l'expérience}

Un soin tout particulier a été apporté à la rédaction du code qui est voulu lisible et efficace.
Une fois les algorithmes vorace et retour arrière implémentés, et la validité approximative des résultats de la méthode vorace vérifiée, les tests ont été lancés sur tous les exemplaires (de 10 à 22 sommets, et largeur 4 à 8). Les tests ont été lancés sans attendre la fin de l'implémentation de l'algorithme dynamique, car la difficulté de celui-ci mettait en doute sa réussite, et la longueur des tests appelait un lancement au plus tôt.

Les données à 26 et 30 sommets, ainsi que celles de largeur 10, ont été écartées à cause de la longueur des tests et de leur consommation trop importante sur une machine personnelle.

Ces tests ont été automatisés, une fois les exécutables créés, par un script Bash écrivant les données brutes dans un fichier importable sous LibreOffice. Ces fichiers, un par exécutable, consignent les temps d'exécution pour chaque jeu de données.

\section{Résultats}

\section{Analyse}

\subsection{Analyse asymptotique}

\subsubsection{Algorithme vorace}
\subsubsection{Algorithme retour arrière}
\subsubsection{Algorithme dynamique}

\subsection{Analyse hybride}

\subsection{Discussion}

\subsubsection{Qualité de réponse}

\subsubsection{Consommation de ressources}

\subsubsection{Implémentation}

\section{Conclusion}

\section{Bibliographie}

Aucune portion de code de l'implémentation ou de la représentation des résultats n'a été copié. Cependant, diverses inspirations ont permis la réalisation de cette expérience.

\begin{itemize}
	\item \href{http://msdn.microsoft.com/en-us/library/hh873134.aspx}{Microsoft Developer Network, Walkthrough: Matrix Multiplication}
	\item \href{http://www.cplusplus.com/reference/vector/vector/}{C++ Reference, Vector class}
	\item \href{http://www.cplusplus.com/doc/tutorial/arrays/}{C++ Reference, Array class}
	\item \href{http://www.cplusplus.com/reference/tuple/tuple/}{C++ Reference, Tuple class}
	\item \href{http://stackoverflow.com/questions/7868936/c-read-file-line-by-line}{Stack Overflow, Réponse de Kerrek SB à la question "Read file line by line"}
	\item Notes de cours "Algorithmes Diviser-pour-Regner", Gilles Pesant
\end{itemize}

\end{document}
